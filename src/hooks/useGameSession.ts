import { useEffect, useState } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useGameStore } from '@/stores/gameStore';
import { useAuth } from '@/hooks/useAuth';
import { toast } from 'sonner';
import { calculateEnergyRegeneration } from '@/lib/energySystem';
import { calculateStreak, getStreakMilestone } from '@/lib/streakSystem';
import { format } from 'date-fns';
import { useSound } from '@/hooks/useSound';
import { generateQuickReplies, calculatePhaseProgress } from '@/lib/quickReplies';
import { LEGENDARY_ARTIFACTS } from '@/lib/artifacts';
import { createArtifactFromDefinition, applyArtifactBonuses } from '@/lib/artifactSystem';
import { ArtifactId, ConversationMode, Phase, TeamMember, Artifact } from '@/types/game';
import { MODE_CONFIGS, isModeUnlocked } from '@/lib/modeConfig';
import { PROMPT_TEMPLATES } from '@/lib/promptTemplates';
import { getCompletedStages, getCurrentStage, STAGE_DEFINITIONS, calculateStageProgress } from '@/lib/stageSystem';
import { getStageReward } from '@/lib/stageRewards';

export function useGameSession() {
  const [loading, setLoading] = useState(true);
  const { user } = useAuth();
  const { 
    setSessionId, updateStats, addMessage, setLoading: setGameLoading, setShowTutorial, 
    setQuickReplies, setAiSuggestedActions, setProjectMetadata, loadStageHistory,
    recordStageCompletion, setShowStageCompletionModal, setPreviousPhaseProgress, unlockMode
  } = useGameStore();
  const { playSound } = useSound();
  const [lastAutoCardEvent, setLastAutoCardEvent] = useState<string | null>(null);
  const [lastAutoCardTime, setLastAutoCardTime] = useState<number>(0);

  // Auto-generate card for significant events
  const autoGenerateCard = async (eventType: string, eventContext: any, messages: any[]) => {
    // Rate limiting: max 1 card per minute
    const now = Date.now();
    if (now - lastAutoCardTime < 60000) {
      console.log('Card generation rate limited');
      return;
    }

    // Don't generate same event type twice in a row
    if (lastAutoCardEvent === eventType) {
      console.log('Skipping duplicate event type:', eventType);
      return;
    }

    try {
      const gameState = useGameStore.getState();
      
      // Get recent messages for context (last 8-10 messages)
      const recentMessages = messages.slice(-10).map(m => ({
        role: m.role,
        content: m.content
      }));

      console.log('Auto-generating card for event:', eventType);
      
      const { data, error } = await supabase.functions.invoke('generate-card-from-conversation', {
        body: {
          sessionId: gameState.sessionId,
          messages: recentMessages,
          currentLevel: gameState.level,
          currentPhase: gameState.currentPhase,
          eventType,
          eventContext,
          autoGenerated: true
        }
      });

      if (error) {
        console.error('Auto card generation error:', error);
        return;
      }

      if (data?.card) {
        setLastAutoCardEvent(eventType);
        setLastAutoCardTime(now);
        
        // Dispatch event for animation
        window.dispatchEvent(new CustomEvent('cardGeneratedWithAnimation', {
          detail: { card: data.card }
        }));
        
        // Show subtle toast
        toast.success('ðŸŽ´ Achievement card created!', {
          description: data.card.title,
          duration: 3000
        });
      }
    } catch (error) {
      console.error('Failed to auto-generate card:', error);
    }
  };

  useEffect(() => {
    if (!user) return;
    
    // Make user available globally for analytics tracking
    (window as any).supabaseUser = user;

    const loadSessionData = async (sessionId: string) => {
      try {
        // Load session metadata for project info
        const { data: sessionData } = await supabase
          .from('game_sessions')
          .select('project_name, project_description, project_color, project_icon')
          .eq('id', sessionId)
          .single();
        
        if (sessionData) {
          setProjectMetadata({
            name: sessionData.project_name,
            description: sessionData.project_description,
            color: sessionData.project_color,
            icon: sessionData.project_icon,
          });
        }

        // Load latest game state
        const { data: latestState } = await supabase
          .from('game_states')
          .select('*')
          .eq('session_id', sessionId)
          .order('created_at', { ascending: false })
          .limit(1)
          .maybeSingle();

        if (latestState) {
          // Check for energy regeneration
          let currentEnergy = latestState.energy;
          let energyGained = 0;
          
          if (latestState.last_energy_update) {
            const { newEnergy, energyGained: gained } = calculateEnergyRegeneration(
              new Date(latestState.last_energy_update),
              latestState.energy
            );
            currentEnergy = newEnergy;
            energyGained = gained;
          }

          // Calculate current stage
          const phaseProgress = calculatePhaseProgress({
            ...latestState,
            currentPhase: latestState.current_phase as Phase
          } as any);
          const currentStage = getCurrentStage(latestState.current_phase as Phase, phaseProgress);
          const stageProgress = calculateStageProgress(latestState.current_phase as Phase, phaseProgress);
          const totalStages = STAGE_DEFINITIONS[latestState.current_phase as Phase]?.length || 4;

          // Load player artifacts
          const { data: playerArtifacts } = await supabase
            .from('player_artifacts')
            .select('artifact_id, unlocked_at')
            .eq('player_id', user.id);

          // Create full artifact objects
          const artifacts = Object.keys(LEGENDARY_ARTIFACTS).map((artifactId) => {
            const unlockedArtifact = playerArtifacts?.find(
              (pa) => pa.artifact_id === artifactId
            );
            return createArtifactFromDefinition(
              artifactId as ArtifactId,
              !!unlockedArtifact
            );
          });

          // Calculate artifact bonuses
          const artifactBonuses = applyArtifactBonuses(artifacts);

          updateStats({
            xp: latestState.xp,
            level: latestState.level,
            spores: latestState.spores,
            energy: currentEnergy,
            streak: latestState.streak,
            codeHealth: latestState.code_health,
            phaseStage: {
              phase: latestState.current_phase as Phase,
              stageNumber: currentStage.stageNumber,
              stageProgress,
              stageLabel: currentStage.label
            },
            currentPhase: latestState.current_phase as Phase,
            completedTasks: (latestState.completed_tasks as any) || [],
            currentTasks: (latestState.current_tasks as any) || [],
            blockers: (latestState.blockers as any) || [],
            bossBlockersDefeated: (latestState.boss_blockers_defeated as any) || [],
            milestones: (latestState.milestones as any) || [],
            teamMood: (latestState.team_mood as any) || {},
            artifacts: artifacts,
            artifactBonuses: artifactBonuses,
            lastSaved: new Date(),
            lastEnergyUpdate: new Date()
          });

          if (energyGained > 0) {
            toast.success(`Regenerated ${energyGained} energy while you were away!`);
          }

          // Check and update daily login streak
          const today = format(new Date(), 'yyyy-MM-dd');
          const { data: todayLogin } = await supabase
            .from('daily_logins')
            .select('*')
            .eq('player_id', user.id)
            .eq('login_date', today)
            .maybeSingle();

          if (!todayLogin) {
            // First login today - update streak
            const { data: recentLogins } = await supabase
              .from('daily_logins')
              .select('login_date')
              .eq('player_id', user.id)
              .order('login_date', { ascending: false })
              .limit(30);

            const loginDates = recentLogins?.map(l => l.login_date) || [];
            const newStreak = calculateStreak(loginDates);
            const milestone = getStreakMilestone(newStreak);

            // Record today's login
            await supabase
              .from('daily_logins')
              .insert({
                player_id: user.id,
                login_date: today
              });

            updateStats({ streak: newStreak });

            if (milestone) {
              toast.success(`ðŸ”¥ ${newStreak} Day Streak!`);
              playSound('levelUp');
            }
          }
        }

        // Load message history
        const { data: messages } = await supabase
          .from('chat_messages')
          .select('*')
          .eq('session_id', sessionId)
          .order('created_at', { ascending: true });

        if (messages) {
          messages.forEach(msg => {
            addMessage({
              id: msg.id,
              role: msg.role as 'user' | 'assistant',
              content: msg.content,
              createdAt: new Date(msg.created_at),
              segments: (msg.segments as any) || [],
              gameEvents: (msg.game_events as any) || []
            });
          });
        }

        // Load stage history
        const { data: stageHistory } = await supabase
          .from('stage_completions')
          .select('*')
          .eq('player_id', user.id)
          .eq('session_id', sessionId)
          .order('completed_at', { ascending: false });

        if (stageHistory) {
          loadStageHistory(stageHistory);
        }

        // Check tutorial progress
        const { data: progress } = await supabase
          .from('player_progress')
          .select('*')
          .eq('player_id', user.id)
          .maybeSingle();

        if (progress) {
          useGameStore.setState({
            tutorialStep: progress.tutorial_step,
            hasCompletedTutorial: progress.has_completed_tutorial,
            showTutorial: !progress.has_completed_tutorial,
            hasMetTeam: progress.has_met_team || false
          });
        } else {
          // Create initial progress record
          await supabase
            .from('player_progress')
            .insert({
              player_id: user.id,
              tutorial_step: 0,
              has_completed_tutorial: false,
              has_met_team: false
            });

          useGameStore.setState({
            tutorialStep: 0,
            hasCompletedTutorial: false,
            showTutorial: true,
            hasMetTeam: false
          });
        }

        setLoading(false);
      } catch (error) {
        console.error('Error loading session data:', error);
        setLoading(false);
      }
    };

    const initSession = async () => {
      try {
        // Clear any existing messages from initial state
        useGameStore.getState().clearMessages();
        
        // Check for URL parameter for shared session
        const urlParams = new URLSearchParams(window.location.search);
        const requestedSessionId = urlParams.get('session');
        
        if (requestedSessionId) {
          // Verify user has access to this session
          const { data: requestedSession, error: sessionError } = await supabase
            .from('game_sessions')
            .select(`
              *,
              session_collaborators!inner(
                player_id,
                access_level,
                accepted_at
              )
            `)
            .eq('id', requestedSessionId)
            .eq('session_collaborators.player_id', user.id)
            .not('session_collaborators.accepted_at', 'is', null)
            .maybeSingle();

          if (sessionError || !requestedSession) {
            toast.error('Session not found - You do not have access to this session');
            // Remove invalid session parameter
            window.history.replaceState({}, '', '/shipit');
          } else {
            // User has access to requested session
            setSessionId(requestedSession.id);
            
            // Set project metadata immediately
            setProjectMetadata({
              name: requestedSession.project_name,
              description: requestedSession.project_description,
              color: requestedSession.project_color,
              icon: requestedSession.project_icon,
            });
            
            await loadSessionData(requestedSession.id);
            return;
          }
        }
        
        // No URL parameter or invalid session - load user's sessions
        // Query for BOTH owned AND shared sessions
        const { data: sessions } = await supabase
          .from('game_sessions')
          .select(`
            *,
            session_collaborators!inner(
              player_id,
              access_level,
              accepted_at
            )
          `)
          .eq('session_collaborators.player_id', user.id)
          .eq('is_active', true)
          .not('session_collaborators.accepted_at', 'is', null)
          .order('created_at', { ascending: false });

        let sessionId: string | undefined;

        if (sessions && sessions.length > 0) {
          // Prioritize owned sessions
          const ownedSession = sessions.find(s => s.player_id === user.id);
          const selectedSession = ownedSession || sessions[0];
          sessionId = selectedSession.id;
          
          // Set project metadata for the selected session
          setProjectMetadata({
            name: selectedSession.project_name,
            description: selectedSession.project_description,
            color: selectedSession.project_color,
            icon: selectedSession.project_icon,
          });
        }

        if (!sessionId) {
          // Create new session
          const { data: newSession, error } = await supabase
            .from('game_sessions')
            .insert({
              player_id: user.id,
              current_phase: 'SPARK',
              is_active: true
            })
            .select()
            .single();

          if (error) throw error;
          sessionId = newSession.id;

          // Create initial game state
          await supabase.from('game_states').insert({
            session_id: sessionId,
            xp: 0,
            level: 1,
            spores: 0,
            energy: 10,
            streak: 0,
            code_health: 100,
            current_phase: 'SPARK',
            completed_tasks: [],
            current_tasks: [
              {
                id: crypto.randomUUID(),
                description: 'Define your product vision and target user',
                xpReward: 25,
                phase: 'SPARK',
                completed: false
              },
              {
                id: crypto.randomUUID(),
                description: 'Identify the core problem you\'re solving',
                xpReward: 25,
                phase: 'SPARK',
                completed: false
              },
              {
                id: crypto.randomUUID(),
                description: 'Brainstorm solution approaches with the team',
                xpReward: 30,
                phase: 'SPARK',
                completed: false
              }
            ],
            blockers: [],
            milestones: [],
            team_mood: {
              ever: 'happy',
              prisma: 'neutral',
              toxic: 'neutral',
              phoenix: 'excited',
              techpriest: 'neutral',
              virgil: 'neutral',
              zen: 'happy'
            }
          });

          // Seed prompt templates if not already seeded
          const { data: existingTemplates } = await supabase
            .from('prompt_library')
            .select('id')
            .eq('is_template', true)
            .limit(1);

          if (!existingTemplates || existingTemplates.length === 0) {
            const templatesWithMetadata = PROMPT_TEMPLATES.map(template => ({
              ...template,
              player_id: user.id,
              is_template: true,
              version: 1,
            }));
            
            await supabase
              .from('prompt_library')
              .insert(templatesWithMetadata);
            
            console.log('Seeded', PROMPT_TEMPLATES.length, 'prompt templates');
          }

          // Add welcome message
          await supabase.from('chat_messages').insert({
            session_id: sessionId,
            role: 'assistant',
            content: 'Welcome to Ship It!',
            segments: [
              {
                type: 'narration',
                content: 'ðŸš€ Welcome to Ship It - where you build products with your AI team!'
              },
              {
                type: 'speech',
                speaker: 'ever',
                content: "Hi! I'm Ever, and I believe in the power of your idea! This team is here to help you go from vision to launch."
              },
              {
                type: 'speech',
                speaker: 'prisma',
                content: "I'm Prisma. I'll keep us focused on data and validation. Let's start with the basics: what problem are you solving?"
              },
              {
                type: 'speech',
                speaker: 'zen',
                content: "And I'm Zen. I'll make sure we build sustainably and don't burn out. Take your time, this is your journey."
              },
              {
                type: 'narration',
                content: 'ðŸ’¡ You\'re in the SPARK phase. Your first quest: define your product vision and identify the core problem you\'re solving.'
              }
            ],
            game_events: []
          });
        }

        if (sessionId) {
          setSessionId(sessionId);
          await loadSessionData(sessionId);
        }
      } catch (error) {
        console.error('Error initializing session:', error);
        toast.error('Failed to load session - Please refresh the page to try again');
        setLoading(false);
      }
    };

    initSession();
  }, [user]);
  
  // Track stage changes and set timestamp when entering new stage
  useEffect(() => {
    const store = useGameStore.getState();
    const phaseProgress = calculatePhaseProgress(store);
    const currentStage = getCurrentStage(store.currentPhase, phaseProgress);
    
    // Monitor for stage changes
    let lastStageKey = `${store.currentPhase}-${currentStage.stageNumber}`;
    
    const unsubscribe = useGameStore.subscribe((state) => {
      const progress = calculatePhaseProgress(state);
      const stage = getCurrentStage(state.currentPhase, progress);
      const stageKey = `${state.currentPhase}-${stage.stageNumber}`;
      
      if (stageKey !== lastStageKey) {
        lastStageKey = stageKey;
        state.setCurrentStageEnteredAt(new Date());
      }
    });
    
    // Set initial timestamp
    if (!store.currentStageEnteredAt) {
      store.setCurrentStageEnteredAt(new Date());
    }
    
    return unsubscribe;
  }, []);

  const sendMessage = async (message: string) => {
    if (!message.trim()) return;
    
    const state = useGameStore.getState();
    const sessionId = state.sessionId;
    
    if (!sessionId) {
      toast.error('No active session');
      return;
    }

    setGameLoading(true);

    try {
      // Add user message
      const userMessage = {
        id: crypto.randomUUID(),
        role: 'user' as const,
        content: message,
        timestamp: new Date(),
        createdAt: new Date(),
        segments: [],
        gameEvents: [],
      };
      addMessage(userMessage);

      // Save user message to database
      await supabase.from('chat_messages').insert({
        session_id: sessionId,
        role: 'user',
        content: message,
      });

      // Generate quick replies from current state
      const quickReplies = generateQuickReplies(state);
      setQuickReplies(quickReplies);

      // Call game-turn function
      const { data, error } = await supabase.functions.invoke('game-turn', {
        body: {
          sessionId,
          message,
          selectedSpeakers: state.selectedSpeakers,
          conversationMode: state.conversationMode,
          responseDepth: state.responseDepth,
        },
      });

      if (error) throw error;

      // Add assistant response
      const assistantMessage = {
        id: crypto.randomUUID(),
        role: 'assistant' as const,
        content: data.response,
        timestamp: new Date(),
        createdAt: new Date(),
        segments: data.segments || [],
        gameEvents: data.gameEvents || [],
        suggestedActions: data.suggestedActions,
      };
      addMessage(assistantMessage);

      // Process any game events
      if (data.gameEvents && data.gameEvents.length > 0) {
        useGameStore.getState().processGameEvents(data.gameEvents);
      }

      // Update stats if provided
      if (data.updatedStats) {
        updateStats(data.updatedStats);
      }

      // Set AI suggested actions
      if (data.suggestedActions) {
        setAiSuggestedActions(data.suggestedActions);
      }

      // Show level up modal if triggered
      if (data.gameEvents?.some((e: any) => e.type === 'LEVEL_UP')) {
        playSound('levelUp');
        const levelUpEvent = data.gameEvents.find((e: any) => e.type === 'LEVEL_UP');
        useGameStore.getState().setShowLevelUpModal(true);
        useGameStore.getState().setLevelUpRewards({
          spores: levelUpEvent.sporesEarned || 0,
          milestone: levelUpEvent.milestone
        });
      }

      // Show phase change toast and auto-generate card
      if (data.gameEvents?.some((e: any) => e.type === 'PHASE_CHANGE')) {
        const phaseEvent = data.gameEvents.find((e: any) => e.type === 'PHASE_CHANGE');
        toast.success(`ðŸŽ‰ Advanced to ${phaseEvent.newPhase} phase!`);
        playSound('levelUp');
        
        // Auto-generate phase change card
        await autoGenerateCard('PHASE_CHANGE', {
          newPhase: phaseEvent.data?.newPhase || phaseEvent.newPhase,
          oldPhase: phaseEvent.data?.oldPhase || phaseEvent.oldPhase,
          timestamp: new Date().toISOString()
        }, state.messages);
      }

      // Handle task completion and auto-generate for high-value tasks
      if (data.gameEvents?.some((e: any) => e.type === 'TASK_COMPLETED')) {
        const taskEvent = data.gameEvents.find((e: any) => e.type === 'TASK_COMPLETED');
        toast.success('Task completed! +XP');
        playSound('levelUp');
        
        // Auto-generate card for high-value tasks (>50 XP)
        if (taskEvent.data?.xpReward && taskEvent.data.xpReward > 50) {
          await autoGenerateCard('TASK_COMPLETED', {
            taskTitle: taskEvent.data.taskTitle || 'Important task',
            xpReward: taskEvent.data.xpReward,
            timestamp: new Date().toISOString()
          }, state.messages);
        }
      }

      // Handle stage completion and auto-generate card
      if (data.gameEvents?.some((e: any) => e.type === 'STAGE_COMPLETE')) {
        const stageEvent = data.gameEvents.find((e: any) => e.type === 'STAGE_COMPLETE');
        const { phase, stageNumber, stageLabel, rewards, timeSpent } = stageEvent.data;
        
        // Record stage completion in database
        try {
          const { data: completionData } = await supabase.from('stage_completions').insert({
            player_id: user!.id,
            session_id: state.sessionId!,
            phase,
            stage_number: stageNumber,
            stage_label: stageLabel,
            xp_earned: rewards.xp,
            time_spent_seconds: timeSpent
          }).select().single();

          // Load updated stage history
          const { data: history } = await supabase
            .from('stage_completions')
            .select('*')
            .eq('player_id', user!.id)
            .eq('session_id', state.sessionId!)
            .order('completed_at', { ascending: false });

          if (history) {
            loadStageHistory(history);
          }

          // Record in store and show modal
          if (completionData) {
            recordStageCompletion(completionData);
          }
          
          setShowStageCompletionModal(true, { phase, stageNumber, stageLabel }, rewards);
          playSound('levelUp');
          
          // Auto-generate stage completion card
          await autoGenerateCard('STAGE_COMPLETE', {
            stageNumber,
            stageLabel,
            phase,
            xpEarned: rewards.xp,
            timestamp: new Date().toISOString()
          }, state.messages);
        } catch (error) {
          console.error('Error recording stage completion:', error);
        }
      }

      // Handle boss blocker defeat and auto-generate card
      if (data.gameEvents?.some((e: any) => e.type === 'BOSS_BLOCKER_DEFEATED')) {
        const bossEvent = data.gameEvents.find((e: any) => e.type === 'BOSS_BLOCKER_DEFEATED');
        const blockerName = bossEvent.data?.blockerName || bossEvent.data?.name;
        toast.success(`Boss Blocker Defeated! ðŸ’ª`, {
          description: blockerName,
          duration: 4000,
        });
        playSound('levelUp');
        
        // Auto-generate boss victory card
        await autoGenerateCard('BOSS_BLOCKER_DEFEATED', {
          blockerName,
          xpReward: bossEvent.data?.xpReward,
          sporesReward: bossEvent.data?.sporesReward,
          timestamp: new Date().toISOString()
        }, state.messages);
      }

      // Handle artifact unlock and auto-generate card
      if (data.gameEvents?.some((e: any) => e.type === 'ARTIFACT_UNLOCKED')) {
        const artifactEvent = data.gameEvents.find((e: any) => e.type === 'ARTIFACT_UNLOCKED');
        const artifactId = artifactEvent.data?.artifactId as ArtifactId;
        const artifactDef = LEGENDARY_ARTIFACTS[artifactId];
        
        if (artifactDef) {
          const artifact = createArtifactFromDefinition(artifactId, true);
          useGameStore.getState().setUnlockedArtifact(artifact);
          useGameStore.getState().setShowArtifactUnlockModal(true);
          playSound('levelUp');
          
          // Auto-generate artifact card
          await autoGenerateCard('ARTIFACT_UNLOCKED', {
            artifactName: artifact.name,
            artifactId,
            description: artifact.description,
            timestamp: new Date().toISOString()
          }, state.messages);
        }
      }

    } catch (error) {
      console.error('Error sending message:', error);
      toast.error('Failed to send message. Please try again.');
    } finally {
      setGameLoading(false);
    }
  };

  const suggestPromptsForPhase = async (phase: Phase) => {
    if (!user) return;

    try {
      const { data: prompts } = await supabase
        .from('prompt_library')
        .select('*')
        .eq('phase', phase)
        .eq('is_template', true)
        .limit(3);

      if (prompts && prompts.length > 0) {
        const promptTitles = prompts.map(p => p.title).join(', ');
        
        const suggestionMessage = {
          id: crypto.randomUUID(),
          role: 'assistant' as const,
          content: `ðŸ’¡ Suggested prompts for ${phase} phase: ${promptTitles}`,
          timestamp: new Date(),
          createdAt: new Date(),
          segments: [],
          gameEvents: [],
        };
        
        addMessage(suggestionMessage);
        toast.info(`Check out ${prompts.length} prompts for the ${phase} phase!`);
      }
    } catch (error) {
      console.error('Error suggesting prompts:', error);
    }
  };

  return { loading, sendMessage };
}
